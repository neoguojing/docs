# 栈
## 栈原理
- 栈帧：函数执行的环境
- 从高地址向低地址延伸，向下生长
- 每个函数的每次调用，都有它自己独立的一个栈帧
- 寄存器ebp指向当前的栈帧的底部（高地址）
- 寄存器esp指向当前的栈帧的顶部（低址地）
```
函数调用大致包括以下几个步骤：
参数入栈：将参数从右向左依次压入系统栈中
返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行（EIP寄存器的值，PC值）
代码区跳转：处理器从当前代码区跳转到被调用函数的入口处
栈帧调整：
具体包括保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）
将当前栈帧切换到新栈帧。（将ESP值装入EBP，更新栈帧底部）
给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶） 被调用函数可以根据sp的值计算参数的地址
```
![栈示意](https://pic2.zhimg.com/1314ce0c49d0a1e2800e23ca3d5cdd75_r.jpg?source=1940ef5c)

## 概念：
- pc： 程序计数器，CPU中用于存放下一条指令地址的寄存器
- sp: 栈帧的栈顶指针
- getcallerpc(): 返回调用该函数的函数的调用者的pc，编译器实现，及上级的上级函数
- getcallersp(): 返回调用该函数的函数的调用者的sp，编译器实现
## 定义：
- _StackCacheSize：32 * 1024
- stackpool ： 全局空闲栈池；linux下为长度为4的数组，依次缓存大小2k 4k 8k 16k的空闲span
- stackLarge： 大栈的池子保存48-13个大小的spanlist？
- FixedStack: linux下为2kb
- 可缓存的空闲栈大小为:2kb\4kb\8kb\16kb,大于16kb的栈则直接分配

# 引用
- https://www.zhihu.com/question/22444939
